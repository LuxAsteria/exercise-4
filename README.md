# exercise-4
***
###`Abstract`
***
Here in this time's exercise, I tried 3 ways--Taylor's solution,Euler's solution and Runge-Kutta's solution to simulate the decay progress, and then calculated the variance of different methods respectively to compare the accuracy of them. Found that in this question, the accuracy of each method is quiet close to each other. However, the simulation applies Runge-Kutta's solution is the most accurate one, then Euler's solution, then Taylor's solution. In fact,these approaches pocesse their own advantages and disadvantages.
###`Background`
***
>Consider again a decay problem with 2 types of nuclei A and  B,but now suppose that nuclei of type A decay intoones of type B, while nuclei of type B decay into type A.Strictly speaking, this is not a "decay" process,since it is possible for the type B nuclei to turn back into type  A nuclei.A better analogy would be a resonance in which a system cna tunnel or move back and forth between 2 states A and B  which have eaual energies.The corresponding rate equations are:
                                    ![latex](https://github.com/LuxAsteria/test3/blob/master/屏幕快照%202016-09-28%20下午1.45.52.png)
                                    
>where for simplicity we have assumed that the 2 types of decay are characterized bu the same time constant ,tau. Solve this system of equations for the numbers of nuclei,N<sub>A</sub> and  N<sub>B</sub> are constant.In such a steady state, the time derivatives  <img src="http://latex.codecogs.com/gif.latex?\frac{dN_{A}}{dt}" alt="" title="" /> and <img src="http://latex.codecogs.com/gif.latex?\frac{dN_{B}}{dt}" alt="" title="" /> should vanish.
###`Exercise`
***
From the questiion, we can solve that differential equations and get 2 functions of N<sub>A</sub> and N<sub>B</sub>:
![latex](https://github.com/LuxAsteria/test3/blob/master/屏幕快照%202016-10-10%20上午9.00.37.png)
![latex](https://github.com/LuxAsteria/test3/blob/master/屏幕快照%202016-10-10%20上午9.01.02.png)

Then the only remaining problem is how to simulate the decay progress and chose which method to do the simulation.

####step 1: Taylor's solution and advanced point--alow to input arbitrary number a and number b:
####First, the most essential part of is solution is to Taylor expand the function around 0 and discard high order indefinit small.About this, our text book<sup>2</sup> has given an spicific explanation,so here i won't illustrate it explicitly.The following picture is generated by the code.
![step1](https://github.com/LuxAsteria/test3/blob/master/step2.png)
####Here's the code<sup>1</sup>:
```
n1=int(input('please enter the number of a:'))
n2=int(input('please enter the number of b:'))
import numpy
import pylab as pl
import math
 class decay:
    """simulation"""
    def __init__(self,num_a=100,num_b=50,time_step=0.05,time_constant=1,time_duration=5):
        self.n_a=[num_a]
        self.n_b=[num_b]
        self.t=[0]
        self.dt=time_step
        self.tau=time_constant
        self.time=time_duration
        self.nsteps=int(time_duration//time_step+1)
    def calculate(self):
        for i in range(self.nsteps):
            tmpa=self.n_a[i]-self.n_a[i]/self.tau*self.dt+self.n_b[i]/self.tau*self.dt
            tmpb=self.n_b[i]-self.n_b[i]/self.tau*self.dt+self.n_a[i]/self.tau*self.dt
            self.n_a.append(tmpa)
            self.n_b.append(tmpb)
            self.t.append(self.t[i]+self.dt)
    def show_results(self):
        pl.plot(self.t,self.n_a,'r')
        pl.plot(self.t,self.n_b,'b')
        pl.xlabel('time')
        pl.ylabel('number')
        pl.show()
    def store_results(self):
        myfile=open('decay.txt','w')
        for i in range(len(self.t)):
            print(self.t[i],self.n_a[i],self.n_b[i],file=myfile)
        myfile.close()
%matplotlib inline
a=decay()
a.calculate()
a.show_results()
a.store_results()
```
####In this step, the picture is drawn with curves,we now draw it using scatter points to compare with the continuous curve generated by its function discribed above,and i've set the initial number of particle a and b as 50 and 100 respectively.
![latex](https://github.com/LuxAsteria/test3/blob/master/taylor%200.05%20r.png)
####It's variance is 4.70963271866e-05 for a and 4.70963271894e-05 for b.
####Change the time step, we can get another simulation with a different variance:
![latex](https://github.com/LuxAsteria/test3/blob/master/taylor%200.025%20right.png)
####It's variance is 1.82915504938e-05 for a and 1.82915504928e-05 for b.
####Here's the code:
```
class decay:
    """simulation"""
    def __init__(self,time_constance=1,time_duration=5,time_step=0.05,number_a=50,number_b=100):
        self.n_a=[number_a]
        self.n_b=[number_b]
        self.dt=time_step
        self.t=[0]
        self.eta=[]
        self.etb=[]
        self.varb=[]
        self.vara=[]
        self.ava=[]
        self.avb=[]
        self.tau=time_constance
        self.nsteps=int(time_duration//time_step+1)
    def calculate_t(self):
        for i in range(self.nsteps):
            tmpa=self.n_a[i]-self.n_a[i]/self.tau*self.dt+self.n_b[i]/self.tau*self.dt
            tmpb=self.n_b[i]-self.n_b[i]/self.tau*self.dt+self.n_a[i]/self.tau*self.dt
            self.n_b.append(tmpb)
            self.n_a.append(tmpa)
            self.t.append(self.t[i]+self.dt)
        for i in range(len(self.t)):
            tempa=0.5*(self.n_b[0]+self.n_a[0])+0.5*(self.n_a[0]-self.n_b[0])*pow(e,-2*self.t[i]/self.tau)
            tempb=0.5*(self.n_a[0]+self.n_b[0])-0.5*(self.n_a[0]-self.n_b[0])*pow(e,-2*self.t[i]/self.tau)
            self.eta.append(tempa)
            self.etb.append(tempb)
            vara=(self.n_a[i]-self.eta[i])**2
            self.vara.append(vara)
            varb=(self.n_b[i]-self.etb[i])**2
            self.varb.append(varb)
        self.ava=sqrt(sum(self.vara[i])/self.nsteps)
        self.avb=sqrt(sum(self.varb[i])/self.nsteps)
    def show_t(self):
        pl.plot(self.t,self.n_a,'*')
        pl.plot(self.t,self.eta)
        pl.plot(self.t,self.n_b,'*')
        pl.plot(self.t,self.etb)
        print(self.avb)
        print(self.ava)
%matplotlib inline
a=decay()
a.calculate_t()
a.show_t()
```
***
####step 2: using Euler's solution to solve the problem.
####First, the brief intriduction:
####Assuming we have the function: f(x,y(x))=y', we can seperate the district [a,b] into n sections, then we get:y'(xi) = f(xi,y(xi)) at the point xi.Using the definition of derivation,we can come to the result that:
![fuc](https://github.com/LuxAsteria/test3/blob/master/屏幕快照%202016-10-09%20下午10.45.26.png)
####then,we have:
![func](
####Here's the picture of simulation when time step is 0.05:
![latex](https://github.com/LuxAsteria/test3/blob/master/euler%20right%200.05.png)
####The variance is 4.7096327188e-05 for a and 4.7096327188e-05 for b.
####When time step is 0.025:
![latex](https://github.com/LuxAsteria/test3/blob/master/euler%20gai.png)
####The variance is 1.82915504928e-05 for a and 1.82915504948e-05 for b.
####Here's the code:
```
  def calculat_euler(self):
        for i in range(self.nsteps):
            tmpa=self.n_a[i]+self.dt*(self.n_b[i]/self.tau-self.n_a[i]/self.tau)
            tmpb=self.n_b[i]+self.dt*(self.n_a[i]/self.tau-self.n_b[i]/self.tau)
            self.n_a.append(tmpa)
            self.n_b.append(tmpb)
            self.t.append(self.t[i]+self.dt)
```
***
####step 3: using R-K's solution to solve the problem.
####Also, let's come to an introduction:
![a](https://github.com/LuxAsteria/test3/blob/master/屏幕快照%202016-10-09%20下午10.55.24.png)
####then let's take the function as:
![a](https://github.com/LuxAsteria/test3/blob/master/屏幕快照%202016-10-09%20下午10.55.11.png)
####So we get:
![a](https://github.com/LuxAsteria/test3/blob/master/屏幕快照%202016-10-09%20下午10.55.14.png)
####h is the timestep.
####Here's the simulation (h=timestep=0.05):
![rk](https://github.com/LuxAsteria/test3/blob/master/rk%20right0.05.png)
####the variance is 4.7096327188e-05 for a and 4.7096327188e-05 for b.
####When h=0.025
![rk](https://github.com/LuxAsteria/test3/blob/master/rk%20gai.png)
####The variance is 1.82915504928e-05 for a and 1.82915504948e-05 for b.
####Here's the code:
```
  def calculate_rk(self):
        for i in range(self.nsteps):
            k1=(self.n_b[i]-self.n_a[i])/self.tau
            m1=(self.n_a[i]-self.n_b[i])/self.tau
            k2=((self.n_b[i]+0.5*self.dt*k1)-(self.n_a[i]+0.5*self.dt*k1))/self.tau
            m2=((self.n_a[i]+0.5*self.dt*m1)-(self.n_b[i]+0.5*self.dt*m1))/self.tau
            k3=((self.n_b[i]+0.5*self.dt*k2)-(self.n_a[i]+0.5*self.dt*k2))/self.tau
            m3=((self.n_a[i]+0.5*self.dt*m2)-(self.n_b[i]+0.5*self.dt*m2))/self.tau
            k4=((self.n_b[i]+self.dt*k3)-(self.n_a[i]+self.dt*k3))/self.tau
            m4=((self.n_a[i]+self.dt*m3)-(self.n_b[i]+self.dt*m3))/self.tau
            tmpa=self.n_a[i]+self.dt*(k1+2*k2+2*k3+k4)/6
            tmpb=self.n_b[i]+self.dt*(m1+2*m2+2*m3+m4)/6
            self.n_a.append(tmpa)
            self.n_b.append(tmpb)
            self.t.append(self.t[i]+self.dt)
```
***
####IT'S conspicuous that the R-K's solution and Euler's solution are more accurate than Taylor's solution while more complex than it. But it's hard to tell which is more accurate when it comes to the choice between R-K's solution and Euler's solution.
***
####step 4:to make the code more spicific.
####To state clearly, we can definite a series of units before we start the program and use them then.
####For instance, I can definite:s=1,then state:time=6(times)s,*which indicates the unite of time is s(second)*.

###`Conclusion`
Here i've shown 3 ways to simulate the decay progress and analyse their accuracy briefly. The R-K's solution and Euler's solution are more accurate whilst the Taylor's solution is easier to use.
When the problem is simple and not require the accuracy, we can chose the Taylor's solution, for its simlicity. However, when the problem needs to be done accurately, we'd better use R-K's solution and Euler's solution.
For the same solution, when the timestep is shorter, the answer will be more accurate.
When it comes to the application in reality, we need to take the real situation and requirement into consideration in order to chose the best solution.

###`Acknowledge`
[1] Professor Cai Hao's basic code

[2]Computational Physics, Edition 2, Nicholas J.Giordano & Hisao Nakanishi


#All rights reserved!All rights reserved!All rights reserved!
